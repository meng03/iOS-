---
title: 链接装载笔记
date: 2019-07-12 20:05:52
tags:
- 读书笔记
- 程序员的自我修养
---



本书共有13章，我对2，3，4，6，7，10比较感兴趣，会比较仔细读这部分，做一些笔记，其他部分，有时间会继续回来学习

## 链接 & 目标文件

现代软件开发，规模通常都很大，使用大量的库，这些库之间如何组成一个单一的程序？库之间如何组合的问题，可以归结为库之间如何通信的问题，最常见的属于静态语言，例如C/C++库之间的通信方式有两种，模块间函数调用，以及模块间变量访问。这两种都需要通过地址访问。所以又可以归结到模块间符号的引用。而链接的作用就是处理好模块之间的符号引用。

链接的过程主要包括了**地址和空间分配（Address and Storage Allocation）**，**符号决议(Symbol Resolution)**以及**重定位（Relocation）**。

库就是一组目标文件的包。

iOS & MacOS平台的目标文件为Mach-O文件。



参考：

<https://www.desgard.com/iOS-Source-Probe/C/mach-o/Mach-O%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%B4%A2.html>

<https://zh.wikipedia.org/wiki/Mach-O>

## 静态连接

### 空间与地址分配

链接是将多个目标文件，组成一个可执行文件的过程，那么如何进行组装呢，上一节了解了目标文件的构成，那合并的思路其实比较简单，就是合并同类的段。这里的空间指的是合并后在可执行文件中的空间，而地址，则是装载后，在虚拟地址空间中的地址。所以链接完成后，地址基本也都分配好了（需要动态链接的部分还需要继续处理）。

#### 第一步 空间与地址的分配

扫描所有的输入目标文件，获得他们的各个段长度，属性和位置，并且将输入目标文件中的符号表收集起来统一放到全局符号表。获取所有输入目标文件的段长度，并将它们合并，，计算输出文件中各个段合并后的长度，位置，并建立映射关系。

#### 第二步 符号解析 & 重定位

合并之后，需要对符号进行解析和重定位，调整代码中的地址。



步骤

* 合并目标文件

  同段的内容合并，比如，所有目标文件的.TEXT段合并成一个大的.TEXT段，合并完成后，文件中的段的虚拟地址空间就有了。并且各个目标文件中的段在最终文件中段的偏移也是有记录的。

* 重新计算地址

  变量和函数相对于段的偏移量，在编译完成时，就已经计算好了，合并成大的段后，需要重新计算函数与变量在合并后文件中相对于段的偏移量。当段在虚拟地址空间中的地址固定后，函数与变量的地址也就固定了。

* 跨目标文件的函数调用以及变量访问的地址计算

  当定义在目标文件中的函数与变量地址固定之后，就可以进行跨目标文件的地址计算了。比如a.o中访问b.o中的`swap`函数，当b.o中`swap`函数地址固定了，就可以将a.o中的swap地址设置到正确的位置上（之前是设定到0x000000，相当于未定义）。



## 装载

### 进程虚拟空间

程序运行起来后就会有自己的虚拟地址空间（Virtual Address Space），虚拟地址从0开始，大小与操作系统相关，32位操作系统，可以寻址4GB，则虚拟地址空间大小为4GB。

之所以是虚拟地址空间，是因为内存大小有限，并不能将所有的程序装载进内存，所以一开始只会将需要的启动函数读进来，后续用到哪部分，就将哪部分读进来，当内存紧张时，会将不常用的内存置换到磁盘。

但是对于进程而言，并不知道这些情况，它会认为自己独占了这4GB的空间。进程虚拟空间会去做地址映射，来保证，程序访问到的部分，都会装载进来。

### 进程的创建过程

* 创建一个独立的虚拟地址空间

  虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，创建虚拟地址空间并不是真的创建空间，而是构造页映射所需要的数据结构。

* 读取程序文件头，建立虚拟空间与可执行文件的映射关系

* 将CPU的指令寄存器设置成可执行文件入口，启动运行

经过这三个步骤，进程就创建成功了，开始运行。CPU执行到入口时，发现这部分并没有读入内存（步骤中确实没有读入内存）。就会发生页错误（Page Fault），CPU将控制权交给操作系统，操作系统根据第二部建立的映射关系，去磁盘相应位置（offset）读取一页的内容放到一个物理页中（从内存中开辟一页空间）。建立虚拟空间与物理页的映射，交还给进程。进程从刚报错的位置继续进行。

随着程序的执行，会不断发生页错误，然后不断将磁盘中的进程数据，读入到内存中。当很多程序同时运行时，很可能会将内存占满，当内存满了以后，会将一部分（根据一些页置换算法）页置换到磁盘，给需要的进程留出空间。

### 装载的优化

发生页错误的时候，会读取一页的数据，装载到内存，因此每个段映射的长度应该都是页的整数倍，最后不足的也会占用一页。当段的数量很多时，会造成很大的浪费。

而对于装载来说，它并不关系段所包含的实际内容，操作系统只关心一些跟装载有关的问题，最主要的是段的权限，，而权限基本上只有三种

* 可读可执行，例如代码段
* 可读可写，例如数据段
* 只读，例如只读数据段

所以将相同权限的段进行合并，可以大大减少内存的浪费。

例如两个可读可执行段，.text和.init，分别为4097字节和512字节，那么分别读入，需要占用三个页，合并后只需要两个页。

## 动态链接

#### 目的

如果没有动态链接，全部库都通过静态链接来处理，会有一些问题

* 非常浪费内存，同样的库会被装载很多遍。
* 模块更新困难

#### 难点

动态链接的难点，就是动态链接库的地址问题。

像静态链接，完成之后，所有的函数与变量的地址就固定了。但是动态链接之后，如果地址固定。那么当其他程序要映射该动态库到自己的虚拟空间时，地址就有可能会有冲突。要想避免这个问题，方法就是动态库中不采用绝对地址，全部使用相对地址。这样，无论这个库被加载到那块内存中，都不影响内部的地址。

这就引出了另一个问题，如何生成地址无关代码，共享对象的地址引用有下面几种情况

* 模块内部函数调用与跳转
* 模块内部的数据访问
* 模块外部的函数调用
* 模块外部的数据访问

前两种情况属于内部的访问，可以通过相对地址访问来处理。

后两种会比较麻烦一点，但是也可以通过一些间接访问来达成。比如ELF中的做法是，在可读可写的数据段中建一个全局偏移表（Global Offset Table , GOT），然后将代码段中对外部的访问指向到GOT，GOT是可写部分，可以在依赖模块装载后在写入。动态库的可读可写数据段每个进程都可以有独立副本，所以对于这部分的修改，不会影响到其他进程。

问题：

GOT中的地址是绝对地址吗？





## 内存







http://www.zoomfeng.com/blog/launch-time.html